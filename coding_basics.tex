\newpage
\section{Coding Basics}
\subsection{C++}
\subsubsection{Template}

Key things to know for template:
\begin{enumerate}
\item as long as the type is specified clearly, template class will be initiated at compile type
\item you can write a factorial calculation at using template at complied time. also {\color{blue}constexpr} will achieve this function as well
\item we can achieve virtual function by using template
\item the template function can do the type deduction, while template class must specify the typename or leave it blank
\item think of var-dict as Type ...
\item template deduction can be used for compiled time calculation
\item template can also be used to achieve static poly-morphism
\end{enumerate}

\subsubsection{Compiled Time Calculation}
This is called template-metaprogramming. You actually store function template dur- ing compliation. Trade-oâ†µ between compile time and run-time. Also, use \textit{ftemplate- depth=200000} to enforce how many recursion you need in compile

\begin{lstlisting}
#include <iostream >
using namespace std;
template<int N> int gauss_sum(){
  return N + gauss_sum <N-1>();
}
template <> int gauss_sum <0>(){
  return 0;
}
int main(int argc, char *argv[]) {
  cout<<gauss_sum <20>() << endl;
  return 0; }
}
\end{lstlisting}

\subsubsection{Variadic Template}

Use variable dict template to write print function

\begin{lstlisting}
#include<iostream>
#include<string>
using namespace std;

template<typename T> void print(const T&t){
  cout << t << endl;
}

template<typename T, typename... Y> void print(const T& first, Y... y){
  cout << first << " ";
  print(y...);
}

int main(){
  print(1, 2, 3, "abc");
}
\end{lstlisting}

\subsubsection{Static Polymorphism (CRTP)}
Polymorphism can be achived using inheritance. You first write a base class as template algorithmm and customize small function using inheritance to overwrite.

Also you can do it using following template pattern
\begin{lstlisting}
#include < iostream >
#include < string >
using namespace std;
template <typename derived > class base{
  public:
  void talk (){
    cout << "my name is " << get_name() << endl;
  }
  string get_name (){
    return static_cast <derived*>(this) -> get_name();
  }
};
// must be public inheritance here otherwise error
class cat: public base <cat >{
  // must add friend here since base class need to // access this method
  private:
  friend string base <cat >:: get_name (); string get_name (){
    return "cat"; }
  };

int main(int argc, char *argv[]) {
    // direct initialize
    cat d; d.talk();
    // use heap to initialize
    base<cat>* c = new cat(); c->talk();
    return 0;
}


\end{lstlisting}

\subsubsection{Perfect Forwarding}

Consider example below, if there is no perfect forwarding, the passed in right value $t$ will become left value if passed to the next function on the stack.
\begin{lstlisting}
#include<utility>
template<typename T, typename U>
std:: pair<T, U>make_pair_wrapper(T&&t, U&&u){
	return std::make_pair(std::forward<T>(t), std::forward<U>(u));
}
\end{lstlisting}
\subsubsection{Smart Pointer}
Key things to remember:
\begin{enumerate}
\item smart pointer will have a internal reference will add 1 when copy, create, go into field and minus 1 when destruct out of field.
\item smart pointer must be copy when returned
\item comment area wont work, no implicit conversion
\item no cycle allowed, use weak pointer.
\end{enumerate}

\begin{lstlisting}
#include<memory>
using namespace std;
/*
int* test(){
  return make_shared<int>(1);
}
*/

shared_ptr<int> test(){
  return make_shared<int>(1);
}
\end{lstlisting}

\subsection{Java}
A bit overview here:
\begin{enumerate}
\item All the value are reference but all the value are passed by value in argument
\item No operator overloading like C++, but {\color{red} except for String that is pre-given}
\item Array does not support allocating generic type \textit{eg. ArrayList}
\item Boolean, String is inmmutable in Java, as well as {\color{blue} Integer, Boolean, etc} wrapper types
\item Java manage memory like convey belt, keep move heap head pointer foward while using GC move what are behind closer to head.
\item {\color{blue} adaptive garbage collection scheme} has two types {\color{blue} Stop And Copy} and {\color{blue} Mark and Sweep}.
\item ArrayList vs Vector/Stack in Java is that the later two are thread safe but slower
\end{enumerate}

\subsubsection{Pass by Value}

Java's references in fact act as a handle (with value in memory) that point to a position of an Object (More like a pointer instead of another name). Therefore, \textit{swap} function like in C++ can not really achieve jobs.

\begin{lstlisting}
class MyObject{
    public MyObject(int x){
        data = x;
    }

    public MyObject(MyObject other){
        data = other.data;
    }
    public int data;
}

class pass_by_reference{
    public static void swap(MyObject a, MyObject b){
        MyObject c = new MyObject(a);
        a = b;
        b = c;
    }

    public static void main(String args[]){
        MyObject a = new MyObject(1);
        MyObject b = new MyObject(2);
        swap(a, b);
        System.out.printf("a: %d, b: %d\n", a.data, b.data);
        // results are: a: 1, b: 2
    }
}
\end{lstlisting}




\subsection{Python}
\subsubsection{Dataframe Data-structure}
\begin{enumerate}
\item pandas.DataFrame is a column major data structure, each colume is a pd.Series (act as a dictionary plus ndarray).
\item DataFrame frame will group all same type data into a block, int, float, datetime64 ... etc
\item string does not have representation in numpy so in pandas, it is a pointer point to other places, which is very slow
\item use {\color{red}category} dtype can solve most of string issue properly
\end{enumerate}

\subsection{MongoDB}

MongoDB has three layers:
\begin{enumerate}
\item Database (equivalent to schema)
\item Collection (equivalent to table)
\item Document (equivalent to row, in json format)
\end{enumerate}

Here are some useful command for mongodb
\begin{lstlisting}
db.createCollection("mycol", { capped : true, autoIndexId : true, size :
   6142800, max : 10000 } )

db.tutorialspoint.insert({"name" : "tutorialspoint"})

db.mycol.find({},{"title":1,_id:0})

db.COLLECTION_NAME.find().sort({KEY:1})

db.COLLECTION_NAME.ensureIndex({KEY:1})

db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])
\end{lstlisting}

MongoDB has easy to config sharding, create backup, map reduce interfaces.
