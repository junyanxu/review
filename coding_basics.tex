\newpage
\section{Coding Basics}
\subsection{C++}
\subsubsection{Template}

Key things to know for template:
\begin{enumerate}
\item as long as the type is specified clearly, template class will be initiated at compile type
\item you can write a factorial calculation at using template at complied time. also {\color{blue}constexpr} will achieve this function as well
\item we can achieve virtual function by using template
\end{enumerate}

\begin{lstlisting}
#include<iostream>
#include<string>
using namespace std;

template <typename T> void show(const T& data){
  if(typeid(data) == typeid(string("abc")))
    cout << "This is a string" << endl;
  if(typeid(data) == typeid(1))
    cout << "This is a int" << endl;
}

int main(){
  show(8);
  show(string("abc"));
}
\end{lstlisting}

\subsubsection{Variadic Template}

Use variable dict template to write print function

\begin{lstlisting}
#include<iostream>
#include<string>
using namespace std;

template<typename T> void print(const T&t){
  cout << t << endl;
}

template<typename T, typename... Y> void print(const T& first, Y... y){
  cout << first << " ";
  print(y...);
}

int main(){
  print(1, 2, 3, "abc");
}
\end{lstlisting}

\subsubsection{Perfect Forwarding}

Consider example below, if there is no perfect forwarding, the passed in right value $t$ will become left value if passed to the next function on the stack. 
\begin{lstlisting}
#include<utility>
template<typename T, typename U>
std:: pair<T, U>make_pair_wrapper(T&&t, U&&u){
	return std::make_pair(std::forward<T>(t), std::forward<U>(u));	
}
\end{lstlisting}
\subsubsection{Smart Pointer}
Key things to remember:
\begin{enumerate}
\item smart pointer will have a internal reference will add 1 when copy, create, go into field and minus 1 when destruct out of field.
\item smart pointer must be copy when returned
\item comment area wont work, no implicit conversion
\item no cycle allowed, use weak pointer.
\end{enumerate}

\begin{lstlisting}
#include<memory>
using namespace std;
/*                                                                              
int* test(){                                                                    
  return make_shared<int>(1);                                                   
}                                                                               
*/

shared_ptr<int> test(){
  return make_shared<int>(1);
}
\end{lstlisting}
\subsection{Python}
\subsubsection{Dataframe Data-structure}
\begin{enumerate}
\item pandas.DataFrame is a column major data structure, each colume is a pd.Series (act as a dictionary plus ndarray).
\item DataFrame frame will group all same type data into a block, int, float, datetime64 ... etc
\item string does not have representation in numpy so in pandas, it is a pointer point to other places, which is very slow
\item use {\color{red}category} dtype can solve most of string issue properly
\end{enumerate}

\subsection{MongoDB}

MongoDB has three layers:
\begin{enumerate}
\item Database (equivalent to schema)
\item Collection (equivalent to table)
\item Document (equivalent to row, in json format)
\end{enumerate}

Here are some useful command for mongodb
\begin{lstlisting}
db.createCollection("mycol", { capped : true, autoIndexId : true, size : 
   6142800, max : 10000 } )
   
db.tutorialspoint.insert({"name" : "tutorialspoint"})

db.mycol.find({},{"title":1,_id:0})

db.COLLECTION_NAME.find().sort({KEY:1})

db.COLLECTION_NAME.ensureIndex({KEY:1})

db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])
\end{lstlisting}

MongoDB has easy to config sharding, create backup, map reduce interfaces.
